---
title: "PCA/EOF tools in *sinkr*"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PCA/EOF tools in *sinkr*}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE, echo=FALSE, results='hide'}
knitr::opts_chunk$set(
	fig.align = "center",
	fig.height = 4.5,
	fig.path = "tex/man-",
	fig.width = 6,
	message = FALSE,
	warning = FALSE,
	cache = FALSE,
	cache.path = "cache/",
	comment = NA
)
```

# Intro

`prcomp` is all you need for most situations. 

What `sinkr` provides is additional functions for:

- conducting PCA/EOF on data with gaps (*i.e.*, NAs). [`dineof`, `eof(..., recursive = TRUE)`]
- determining "significant" principal components (PCs), *i.e.*, those that carry signal above background noise. [methods for full (`pca_loo`, `pca_kcv`) and gappy data (repeated `dineof`)]
  - Mention Scree plot for visual examination
- determining "non-mixed" PCs, *i.e.*, those whose amplitude is significantly higher than its neighbours, and thus may be interpreted more directly. [`prcompBoot`, `eofBoot`]


## Set-up

```{r}
library(sinkr)
library(pals)
library(maps)
library(ggplot2)
```

## Sample datasets

```{r}
# iris morphology
iris2 <- iris[,1:4]
iris2sc <- scale(iris2) # centered and scaled

# wine characteristics
data(wine)
wine2 <- wine[,names(wine)!="Type"]
wine2sc <- scale(wine2) # centered and scaled

# Synthetic data field
data(Xt)

# The "noisy" field
# noise standard deviation at 10% noise-to-signal ratio
noise_sd <- 0.1 * sd(as.vector(Xt))

# Add Gaussian noise
set.seed(123)  # For reproducibility
Xn <- Xt + rnorm(length(Xt), mean = 0, sd = noise_sd)
Xn <- array(Xn, dim = dim(Xt))

par(mfrow = c(1,3), mar = c(3,3,2,1), mgp = c(2,0.5,0))
image(t(as.matrix(iris2sc)), col = viridis(100))
mtext("iris2 (scaled)", line = 0.5)
image(t(as.matrix(wine2sc)), col = viridis(100))
mtext("wine2 (scaled)", line = 0.5)
image(t(Xn), col = viridis(100))
mtext("Synthetic", line = 0.5)
```


# Determining significant patterns

Large.scale patterns
Later EOFs may still explain smal-scale features (and noise).


## Visual inspection


```{r}
p_iris2sc <- prcomp(iris2sc)
p_wine2sc <- prcomp(wine2sc)
p_Xt <- prcomp(Xt)
p_Xn <- prcomp(Xn)

par(mfcol = c(1,3), mar = c(3,3,2,1), mgp = c(2,0.5,0))
plot(p_iris2sc$sdev^2, t = "b", log = "y", ylab = "Variances (log-scaled)")
mtext("iris2 (scaled)", line = 0.5)
plot(p_wine2sc$sdev^2, t = "b", log = "y", ylab = "Variances (log-scaled)")
mtext("wine2 (scaled)", line = 0.5)
plot(p_Xt$sdev[1:20]^2, t = "b", log = "y", ylab = "Variances (log-scaled)")
mtext("Synthetic", line = 0.5)
lines(p_Xn$sdev[1:20]^2, t = "b", col = 2, pch = 2)
legend("bottomleft", legend = c("Xt (True)", "Xn (w/ noise)"), pch = c(1,2), col = 1:2, bty = "n")


```




Three available functions



```{r}
res_loocv <- pca_loocv(wine2sc)
res_loocv <- lapply(res_loocv, colSums)$pseudoinverse
loocv_nsig <- which(res_loocv==min(res_loocv))

set.seed(1)
res_kcv <- pca_kcv(wine2sc, ks = 5, verbose = FALSE)
res_kcv <- lapply(res_kcv, colSums)$pseudoinverse
kcv_nsig <- which(res_kcv==min(res_kcv))

par(mar = c(4,4,1,1))
plot(res_loocv, log = "y", t = "b", pch = 21, col = 3, bg = c(NA,3)[(seq(res_loocv)==loocv_nsig)+1])
lines(res_kcv, t = "b", pch = 21, col = 4, bg = c(NA,4)[(seq(res_kcv)==kcv_nsig)+1])

```


```{r}
set.seed(2)
ks <- kfold(length(wine2sc), k = 20)
dineof_nsig <- lapply(ks, FUN = function(x){
  dineof(wine2sc, ref.pos = x, delta.rms = 1e-2, verbose = FALSE)$n.eof
})
unlist(dineof_nsig)
median(unlist(dineof_nsig))
```



## Apply methods to example data

There are 9 signals in the true field, `Xt`, but some of these are masked by noise in `Xn`.


Depending on the matrix size, one or the other approach may be significantly faster.

One difference is that the `pca_loocv` and `pca_kcv` approaches apply a second centering to each cross validation -- based on the validation dataset, and applied to the test dataset. In the case of `dineof`, all centering and scaling must be done outside of the function.  

Also note that the reference points used in dineof should be kept small in order not to remove to much signal?

```{r}

df <- expand.grid(
  method = c("pca_kcv", "dineof"), 
  dataset = c("iris2", "iris2sc", "wine2sc", "Xt", "Xn"), 
  stringsAsFactors = F)
df$nsig <- NaN
for(i in seq(nrow(df))){
  # print(i)
  dat <- as.matrix(get(df$dataset[i]))
  meth <- df$method[i]
  
  if(meth == "pca_kcv"){
    set.seed(3)
    res <- pca_kcv(dat, ks = 5, verbose = FALSE)
    res <- lapply(res, colSums)$pseudoinverse
    res <- which(res == min(res))
    df$nsig[i] <- res
  }
  
  if(meth == "dineof"){
    set.seed(3)
    ks <- kfold(length(as.matrix(dat)), k = 20)
    res <- lapply(ks, FUN = function(x){
      dineof(dat, ref.pos = x, delta.rms = 1e-2, verbose = FALSE)$n.eof
    })
    res <- median(unlist(res))
    df$nsig[i] <- res
  }

}

df

```
## A largish example

```{r}
data(sst)

# prcomp(sst$field) # this would fail due to empty columns

# remove empty columns
incl <- which(colSums(is.na(sst$field)) == 0)
dat <- sst$field[,incl]
P <- prcomp(dat)

# or use eof()
E <- eof(sst$field)

# results are nearly identical
par(mar = c(4,4,1,1))
plot(P$sdev[1:50]^2, E$Lambda[1:50], log = "xy")
abline(0,1)

```

Patterns

```{r, fig.height=6}
eof.num <- 2 # EOF number to plot
par(no.readonly=TRUE, mgp = c(2,0.5,0))
layout(matrix(c(1,3,2,3),nrow=2, ncol=2), widths=c(5,1), heights=c(3,3), respect = TRUE)
par(cex=1, mar=c(4,4,1,1))
PAL <- colorPalette(c("blue", "cyan", "grey90", "yellow", "red"), c(10,1,1,10))
ZLIM <- c(-1,1)*max(abs(E$u[,eof.num]))
COL <- val2col(E$u[,eof.num], col=PAL(100), zlim=ZLIM)
plot(lat ~ lon, data=sst$grid, pch=22, bg=COL, col=COL, cex=2)
mtext(paste("EOF", eof.num))
map("world", add=TRUE)
par(mar=c(4,0,1,4))
imageScale(E$u[,eof.num], col=PAL(100), zlim=ZLIM, axis.pos=4)
par(mar=c(4,4,1,4))
plot(sst$date, E$A[,eof.num], t="l", xlab = "", ylab = "")
lines(loess.smooth(sst$date, E$A[,eof.num], span=1/3), col=rgb(0.5,0.5,1), lwd=2) # smoothed signal
abline(h=0, v=seq(as.Date("1000-01-01"), as.Date("2100-01-01"), by="10 years"), col=8, lty=3)
mtext(paste("PC", eof.num))
```





How many are significant? `pca_kcv` and `pca_loocv` take too long. `dineof` is more straightforward, but less iterations may be desired due to the size of the data matrix. Here is an example with a single dineof iteration with 5% of the data as the reference holdout set.

```{r}
datsc <- scale(dat, scale = FALSE)
set.seed(3)
ks <- kfold(length(as.matrix(dat)), k = 10)
D <- dineof(datsc, delta.rms = 1e-2, ref.pos = ks[[1]], verbose = F)

par(mar = c(4,4,2,1))
plot(E$Lambda[1:30], log = "y", ylab = "Variance")
mtext("Screeplot of sst EOF Lambda values,\nplus dineof-derived significance threshold")
abline(v = D$n.eof, lty = 2)

```




# PCA/EOF on gappy data

```{r}

dat <- wine2sc #Xn

attr(dat, "scaled:center") <- NULL
attr(dat, "scaled:scale") <- NULL

set.seed(4)

# 20% gaps
frac_gaps <- 0.2
gaps <- sample(length(dat), length(dat)*frac_gaps)
dat_g <- dat
dat_g[gaps] <- NaN

image(t(dat_g), col = viridis(100))
mtext("wine2 (scaled) with 20% gaps", line = 0.5)

# 10% of non-gaps as reference
ref.pos <- sample(seq(dat_g)[-gaps], sum(!is.na(dat_g))*0.1)


# dineof to interpolate, then prcomp or other 
D <- dineof(dat_g, ref.pos = ref.pos, delta.rms = 1e-2, verbose = F, method = "svds")
P <- prcomp(D$Xa, center = F, scale. = F)

# direct rseof  
E <- eof(dat_g, recursive = TRUE, centered = F, scaled = F)
```

## compare reconstruction

```{r gappy_recon}
res <- expand.grid(n = seq(E$Lambda), method = c("dineof+prcomp", "rseof"),
  data = c("gaps", "non-gaps", "all"), stringsAsFactors = FALSE)
res$rmse <- NaN

for(i in seq(E$Lambda)){
  R1 <- prcompRecon(P, pcs = seq(i))
  R2 <- eofRecon(E, pcs = seq(i), uncenter = F, unscale = F)
  
  # gaps
  idx <- which(res$n == i & res$method == "dineof+prcomp" & res$data == "gaps")
  res$rmse[idx] <- sqrt(mean((dat[gaps] - R1[gaps])^2))
  idx <- which(res$n == i & res$method == "rseof" & res$data == "gaps")
  res$rmse[idx] <- sqrt(mean((dat[gaps] - R2[gaps])^2))
  
  # non-gaps
  idx <- which(res$n == i & res$method == "dineof+prcomp" & res$data == "non-gaps")
  res$rmse[idx] <- sqrt(mean((dat[-gaps] - R1[-gaps])^2))
  idx <- which(res$n == i & res$method == "rseof" & res$data == "non-gaps")
  res$rmse[idx] <- sqrt(mean((dat[-gaps] - R2[-gaps])^2))
  
  # all
  idx <- which(res$n == i & res$method == "dineof+prcomp" & res$data == "all")
  res$rmse[idx] <- sqrt(mean((dat[] - R1[])^2))
  idx <- which(res$n == i & res$method == "rseof" & res$data == "all")
  res$rmse[idx] <- sqrt(mean((dat[] - R2[])^2))
  
}

ggplot(res) + aes(x = n, y = rmse, group = method, color = method) +
  facet_grid(~data) +
  geom_vline(xintercept = D$n.eof, lty = 2) +
  geom_line() #+ scale_y_log10(limits = c(0.1, NA)) 

```









