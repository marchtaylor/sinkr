% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dineof.R
\name{dineof}
\alias{dineof}
\title{DINEOF (Data Interpolating Empirical Orthogonal Functions)}
\usage{
dineof(
  Xo,
  n.max = NULL,
  ref.pos = NULL,
  delta.rms = 0.001,
  method = "svds",
  verbose = TRUE
)
}
\arguments{
\item{Xo}{A gappy data field.}

\item{n.max}{A maximum number of EOFs to iterate 
(leave equalling "NULL" if algorithm shold proceed until convergence)}

\item{ref.pos}{A vector of non-gap reference positions by which 
errors will be assessed via root mean squared error ("RMS"). 
If ref.pos = NULL, then either 30 or 1 \% of the non-gap values 
(which ever is larger) will be sampled at random.}

\item{delta.rms}{The threshold for RMS convergence. Technically, the 
improvement in the ratio of root-mean-squared error to standard deviation
of the known values in Xo.}

\item{method}{Method to use for matrix decomposition (\code{\link[base]{svd}}, 
\code{\link[irlba]{irlba}}, \code{\link[RSpectra]{svds}}).
Default is \code{method="svds"}, which is more computationally efficient
for large matrices. \code{method="irlba"} can also be used for partial 
decomposition, and is included for consistency with 
previous versions of the sinkr package.}

\item{verbose}{logical. Print progress (Default: verbose = TRUE).}
}
\value{
Results of \code{dineof} are returned as a list 
containing the following components:
\tabular{rll}{
\tab \code{Xa} \tab The data field with interpolated values (via EOF reconstruction) included.\cr
\tab \code{n.eof} \tab The number of EOFs used in the final solution.\cr
\tab \code{RMS} \tab A vector of the RMS values from the iteration.\cr
\tab \code{NEOF} \tab A vector of the number of EOFs used at each iteration.\cr
}
}
\description{
This function is based on the 
DINEOF (Data Interpolating Empirical Orthogonal Functions) 
procedure described by Beckers and Rixon (2003). The procedure has been
shown to accurately determine Emprirical Orthogonal Functions (EOFs) from 
gappy data sets (Taylor et al. 2013) that are used for data 
reconstruction. Rather than directly return the EOFs, 
the results of the \code{dineof} function is a fully interpolated 
matrix which can then be subjected to a final EOF decomposition with 
\code{eof}, \code{prcomp}, or other EOF/PCA function of preference.
}
\details{
Method \code{"svds"} is now the default as it provides 
better estimates of trailing EOFs than \code{"irlba"} and can be 
computationally faster during later iterations where multiple singular vectors 
are calculated.
}
\examples{
data(Xt)

# The "noisy" field
# noise standard deviation at 10\% noise-to-signal ratio
noise_sd <- 0.1 * sd(as.vector(Xt))

# Add Gaussian noise
set.seed(123)  # For reproducibility
Xn <- Xt + rnorm(length(Xt), mean = 0, sd = noise_sd)
Xn <- array(Xn, dim = dim(Xt))

# The "observed" gappy field field
set.seed(1)
frac.gaps <- 0.5
gaps <- sample(seq(length(Xn)), frac.gaps*length(Xn))
Xo <- replace(Xn, gaps, NaN)

# The dineof "interpolated" field
set.seed(1)
RES <- dineof(Xo, delta.rms = 1e-05) # lower 'delta.rms' for higher resolved interpolation
Xa <- RES$Xa

# Visualization all fields
pal <- colorRampPalette(c("blue", "cyan", "yellow", "red"))
ZLIM <- range(Xt, Xn, Xo, Xa, na.rm=TRUE)

op <- par(mfrow=c(2,2), mar=c(1,1,3,1))
image(z=Xt, zlim=ZLIM, main="A) True", 
  col=pal(100), xaxt="n", yaxt="n", xlab="", ylab="")
box()
image(z=Xn, zlim=ZLIM, main= "B) True + Noise", 
  col=pal(100), xaxt="n", yaxt="n", xlab="", ylab="")
box()
image(z=Xo, zlim=ZLIM, main="C) Observed (gappy)", 
  col=pal(100), xaxt="n", yaxt="n", xlab="", ylab="")
box()
image(z=Xa, zlim=ZLIM, main="D) Reconstruction", 
  col=pal(100), xaxt="n", yaxt="n", xlab="", ylab="")
box()
par(op)




### Example with iris dataset
iris2 <- as.matrix(iris[,1:4]) # only use numeric morphometric data
frac.gaps <- 0.3 # fraction NaN values

# make gappy dataset
set.seed(1)
gaps <- sample(seq(length(iris2)), frac.gaps*length(iris2))
iris2g <- replace(iris2, gaps, NaN)

# The dineof "interpolated" field
# using method = "svd" is more stable if neof might reach nmax
set.seed(1)
RES <- dineof(iris2g, method="svd")  

# plot results
plot(iris2, RES$Xa, 
   col = rep(rainbow(ncol(iris2)), each = nrow(iris2)),
   pch = as.numeric(iris$Species), main = "Imputation w/ DINEOF"
)
abline(0,1,col=8, lty=1)
legend("topleft", legend=colnames(iris2), col=rainbow(ncol(iris2)), lty=1, bty = "n")
legend("bottomright", legend=levels(iris$Species), pch=1:3, bty = "n")
sqrt(mean((iris2[gaps] - RES$Xa[gaps])^2, na.rm=TRUE)) # root mean square error





}
\references{
Beckers, J-M, and M. Rixen. "EOF Calculations and Data Filling from 
Incomplete Oceanographic Datasets." Journal of Atmospheric and Oceanic 
Technology 20.12 (2003): 1839-1856.

Taylor, Marc H., Martin Losch, Manfred Wenzel, Jens Schroeter (2013). 
On the Sensitivity of Field Reconstruction and Prediction Using 
Empirical Orthogonal Functions Derived from Gappy Data. J. Climate, 
26, 9194-9205.
}
\keyword{EOF}
\keyword{PCA}
\keyword{algorithm}
\keyword{gappy}
